#!/bin/sh
# -*- scheme -*-
# @configure_input@
GUILE_LOAD_PATH="$1${GUILE_LOAD_PATH:+:}$GUILE_LOAD_PATH"
export GUILE_LOAD_PATH
exec ${GUILE:-@GUILE@} --no-auto-compile -e main -s "$0" "$@"
!#
;;;; evaluate -- convert a specification to a job list
;;; Copyright © 2016, 2018 Ludovic Courtès <ludo@gnu.org>
;;; Copyright © 2016, 2017 Mathieu Lirzin <mthl@gnu.org>
;;; Copyright © 2017 Mathieu Othacehe <m.othacehe@gmail.com>
;;;
;;; This file is part of Cuirass.
;;;
;;; Cuirass is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; Cuirass is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Cuirass.  If not, see <http://www.gnu.org/licenses/>.

(use-modules (cuirass)
             (ice-9 match)
             (ice-9 pretty-print)
             (srfi srfi-26)
             (guix build utils)
             (guix derivations)
             (guix store))

(define* (main #:optional (args (command-line)))
  (match args
    ((command load-path guix-package-path source specstr)
     ;; Load FILE, a Scheme file that defines Hydra jobs.
     (let ((%user-module (make-fresh-user-module))
           (spec         (with-input-from-string specstr read))
           (stdout       (current-output-port))
           (stderr       (current-error-port)))
       (save-module-excursion
        (lambda ()
          (set-current-module %user-module)
          (with-directory-excursion source
            (primitive-load (assq-ref spec #:file)))))
       (with-store store
         (unless (assoc-ref spec #:use-substitutes?)
           ;; Make sure we don't resort to substitutes.
           (set-build-options store #:use-substitutes? #f #:substitute-urls '()))

         ;; Grafts can trigger early builds.  We do not want that to happen
         ;; during evaluation, so use a sledgehammer to catch such problems.
         ;; An exception, though, is the evaluation of Guix itself, which
         ;; requires building a "trampoline" program.
         (let ((real-build-things build-things))
           (set! build-things
             (lambda (store . args)
               (simple-format stderr "warning: building things during evaluation~%")
               (simple-format stderr "'build-things' arguments: ~S~%" args)
               (apply real-build-things store args))))

         (parameterize ((%use-substitutes? (assoc-ref spec #:use-substitutes?)))
           (unless (string-null? guix-package-path)
             (set-guix-package-path! guix-package-path))
           ;; Call the entry point of FILE and print the resulting job sexp.
           ;; Among the arguments, always pass 'file-name' and 'revision' like
           ;; Hydra does.
           (let* ((proc-name (assq-ref spec #:proc))
                  (proc    (module-ref %user-module proc-name))
                  (commit  (assq-ref spec #:current-commit))
                  (name    (assq-ref spec #:name))
                  (args    `((,(string->symbol name)
                              (revision . ,commit)
                              (file-name . ,source))
                             ,@(or (assq-ref spec #:arguments) '())))
                  (thunks  (proc store args))
                  (eval    `((#:specification . ,name)
                             (#:revision . ,commit))))
             (pretty-print
              `(evaluation ,eval
                           ,(map (lambda (thunk)
                                   (call-with-time-display thunk))
                                 thunks))
              stdout))))))
    ((command _ ...)
     (simple-format (current-error-port) "Usage: ~A FILE
Evaluate the Hydra jobs defined in FILE.~%"
                    command)
     (exit 1))))
